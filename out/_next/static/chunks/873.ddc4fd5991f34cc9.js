"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[873],{3873:(e,r,t)=>{t.d(r,{idbDelete:()=>i,idbGet:()=>a,idbPut:()=>s});let n="remoteFiles";function o(){return new Promise((e,r)=>{if(!window.indexedDB)return void r(Error("IndexedDB not available"));let t=indexedDB.open("spark-viewer",1);t.onupgradeneeded=()=>{let e=t.result;e.objectStoreNames.contains(n)||e.createObjectStore(n)},t.onsuccess=()=>e(t.result),t.onerror=()=>r(t.error)})}async function s(e,r){let t=await o();return new Promise((o,s)=>{let a=t.transaction(n,"readwrite").objectStore(n),i=r instanceof Uint8Array?r.buffer:r,c=a.put(i,e);c.onsuccess=()=>o(),c.onerror=()=>s(c.error)})}async function a(e){let r=await o();return new Promise((t,o)=>{let s=r.transaction(n,"readonly").objectStore(n).get(e);s.onsuccess=()=>{var e;return t(null!=(e=s.result)?e:null)},s.onerror=()=>o(s.error)})}async function i(e){let r=await o();return new Promise((t,o)=>{let s=r.transaction(n,"readwrite").objectStore(n).delete(e);s.onsuccess=()=>t(),s.onerror=()=>o(s.error)})}}}]);